# Интерфейсы

Подобно псевдонимам типов, интерфейсы являются способом назвать тип без необходимости определять его встроенным. Псевдонимы типов и интерфейсы — это в целом два синтаксиса для одной задачи (как выражения и декларации функций), но есть небольшие отличия. Начнем с изучения их общих характеристик. Рассмотрите следующий псевдоним типа:

```
type Sushi = {
    calories: number
    salty: boolean
    tasty: boolean
}
```

Его легко переписать в виде интерфейса:

```
interface Sushi {
    calories: number
    salty: boolean
    tasty: boolean
}
```

Псевдоним типа Sushi можно заменить на интерфейс Sushi. Обе декларации определяют формы, и эти формы являются совместимыми (на деле они идентичны).

Становится интереснее, когда вы начинаете комбинировать типы. Смоделируем дополнительную еду:

```
type Cake = {
    calories: number
    sweet: boolean
    tasty: boolean
}
```

Наличие калорий и вкуса свойственно разной еде — не только Sushi и Cake. Поэтому давайте выделим Food в отдельный тип и переопределим виды еды в нем:

```
type Food = {
    calories: number
    tasty: boolean
}

type Sushi = Food & {
    salty: boolean
}

type Cake = Food & {
    sweet: boolean
}
```

Почти идентично вы можете проделать то же самое с интерфейсами:

```
interface Food {
    calories: number
    tasty: boolean
}

interface Sushi extends Food {
    salty: boolean
}

interface Cake extends Food {
    sweet: boolean
}
```

{% hint style="info" %}
Интерфейсы не обязательно должны расширять другие интерфейсы. На деле интерфейс может расширить любую форму: объект type, class или другой interface.
{% endhint %}



### Отличие типов от интерфейсов

В чем отличие типов от интерфейсов? Отличия три, и они не сильно выражены.

**Во-первых**, псевдонимы типов более обобщены: их правая часть может быть любого типа, включая выражение типа (тип и, возможно, операции вроде & или |). А правая часть интерфейса должна быть формой. Следующие псевдонимы типов никак не переписать в виде интерфейсов:

```
type A = number
type B = A | string
```

**Во-вторых**, при расширении интерфейса TypeScript будет проверять, совместим ли этот интерфейс с произведенным вами расширением:

```
interface A {
    good(x: number): string
    bad(x: number): string
}

interface B extends A {
    good(x: string | number): string
    bad(x: string): string // Ошибка TS2430: Interface 'B' некорректно расширяет 
    //interface 'A'. Тип 'number' несовместим с типом 'string'.
}
```

Это не тот случай, когда вы используете типы пересечений: если вы превратите интерфейсы из последнего примера в псевдонимы типов и расширите (extends) их в пересечения (&), TypeScript постарается скомбинировать это расширение с расширяемым типом, формируя в итоге перегруженную сигнатуру для bad вместо выдачи ошибки при компиляции (проверьте это в редакторе).

Когда вы моделируете наследование для типов объектов, проверка совместимости, производимая TypeScript в отношении интерфейсов, может оказаться очень полезной для перехвата ошибок.

**В-третьих**, несколько интерфейсов с одинаковым именем в одной области подвергаются автоматическому слиянию. А несколько одноименных псевдонимов типов в одной области будут вызывать ошибку при компиляции. Эта особенность называется слиянием деклараций.

### Слияние деклараций

Слияние деклараций в TypeScript — это способ автоматического комбинирования нескольких деклараций, имеющих одинаковое имя. Мы уже встречались с этим процессом, когда [знакомились с перечислениями](podrobno-o-tipakh/enum.md#neskolko-deklaracii). В текущем подразделе мы вкратце познакомимся со слиянием деклараций в контексте интерфейсов.

Если вы объявите два одноименных интерфейса User, TypeScript автоматически объединит их в один интерфейс:

```
// User имеет одно поле, name
interface User {
    name: string
}

// Теперь User имеет два поля, name и age
interface User {
    age: number
}

let a: User = {
    name: 'Ashley',
    age: 30
}
```

Вот что произойдет, если вы повторите этот пример с псевдонимами типов:

```
type User = { // Ошибка TS2300: повторяющийся идентификатор 'User'.
    name: string
}

type User = { // Ошибка TS2300: повторяющийся идентификатор 'User'.
    age: number
}
```

Обратите внимание, что два интерфейса не должны конфликтовать. Если один типизирует property(свойство) как T, а другой типизирует его как U и T не совпадет с U, тогда вы получите ошибку:

```
interface User {
    age: string
}

interface User {
    age: number // Ошибка TS2717: последующие декларации свойств
    // должны иметь тот же тип.
    // Свойство 'age' должно иметь тип 'string',
    // но здесь имеет тип 'number'.
}
```
