# Функции

В JavaScript функции являются объектами первого уровня. Это означает, что их можно использовать как объекты: присваивать переменным, передавать другим функциям, возвращать из функций, присваивать объектам и прототипам, записывать в них свойства, считывать эти свойства и т. д. TypeScript моделирует все эти возможности с помощью своей богатой системы типов.

Так выглядит функция в TypeScript (пример вам знаком из предыдущей главы):

```
function sum(a: number, b: number) {
    return a + b
}
```

Обычно параметры функции аннотируются явно (a и b в этом примере). TypeScript выводит типы в теле функции, но не для параметров, за исключением нескольких ситуаций, когда он ориентируется на контекст. Возвращаемый тип подлежит выводу, но при желании его можно аннотировать явно:

```
function sum(a: number, b: number): number {
    return a + b
}
```

Но лучше возвращаемый тип функции переложить на плечи TS и не указывать его явно.

### Сигнатуры вызовов (тип функции)

Недавно мы объявляли функцию, где в параметрах прописывали нужные типы. Как еще можно типизировать sum? sum — это функция, получающая два значения и возвращающая number. Выразим ее тип так:

```
(a: number, b: number) => number
```

В TypeScript такой синтаксис используется для обозначения** типа функции**. Иначе он называется **сигнатурой вызова (или типа)**. Он похож на стрелочную функцию — так и задумано. Вы будете использовать этот синтаксис для типизации функций при их передаче в виде аргументов или при их возвращении из других функций.

{% hint style="info" %}
Имена параметров a и b просто служат для документации и не влияют на совместимость функции с типом.
{% endhint %}

Сигнатуры вызовов функций содержат только код уровня типов, то есть только типы, без значений. Так они могут выражать типы параметров (в том числе опциональных), типы this, возвращаемые типы, оставшиеся типы, но не могут выражать значения по умолчанию (поскольку это не типы). И так как у них нет тела, по которому TypeScript мог бы сделать вывод, они требуют явного аннотирования **возвращаемых** типов.

Вот некоторые примеры сигнатур функций:

```
type Greet = (name: string) => string

type Log = (message: string, userId?: string) => void

type SumVariadicSafe = (...numbers: number[]) => number
```

Теперь конкретизируем связи между сигнатурами вызовов и их реализациями.

```
type Log = (message: string, userId?: string) => void

let log: Log = (
    message,
    userId = 'Not signed in'
) => {
    let time = new Date().toISOString()
    console.log(time, message, userId)
}
```

