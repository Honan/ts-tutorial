# Перегрузка функций

Использованный в предыдущем разделе синтаксис типизации функции — type Fn = (…) => … — является сокращением сигнатуры вызова. Можно написать его более явно. Еще раз возьмем пример с Log:

```
// Сокращенная сигнатура вызова
type Log = (message: string, userId?: string) => void

// Полная сигнатура вызова
type Log = {
    (message: string, userId?: string): void
}
```

Оба варианта во всех случаях будут взаимными эквивалентами, разница останется только в синтаксисе.

Для простых случаев вроде нашей функции Log стоит предпочесть сокращение, но для более сложных функций есть несколько существенных причин использовать полную сигнатуру.

Первая из них - это **перегрузка **типа функции. Но сначала разберемся, что значит перегрузка функции.

**Перегруженная функция** - функция с несколькими [сигнатурами вызовов](./#signatury-vyzovov-tip-funkcii).

Вы можете использовать перегруженные сигнатуры функций для проектирования самых выразительных API. Например, спроектируем API для бронирования отпуска — назовем его Reserve. Начнем с зарисовки его типов (с полной сигнатурой):

```
type Reserve = {
    (from: Date, to: Date, destination: string): Reservation
}
```

Теперь подытожим реализацию Reserve:

```
let reserve: Reserve = (from, to, destination) => {
// ...
}
```

Итак, пользователь, желающий забронировать путешествие на Бали, должен вызвать API reserve с датами from и to, а также "Bali" в виде назначения.

Мы можем видоизменить API для поддержки рейсов в один конец:

```
type Reserve = {
    (from: Date, to: Date, destination: string): Reservation
    (from: Date, destination: string): Reservation
}
```

Вы заметите, что при попытке запустить код TypeScript выдает ошибку в месте, где вы реализуете Reserve.

![Ошибка типа при упущении комбинированной сигнатуры перегрузки](<../.gitbook/assets/image (1).png>)

Это происходит из-за особенности работы перегрузки сигнатуры в TypeScript. Если вы объявите набор сигнатур перегрузки для функции f, то с точки зрения вызывающего компонента тип f — это объединение сигнатур перегрузок. Но с позиции реализации f должен быть один скомбинированный тип, который может быть реализован. Вам придется самостоятельно объявить эту комбинированную сигнатуру вызова при реализации f. В примере с Reserve можете обновить функцию reserve так:

```
let reserve: Reserve = (
    from: Date,
    toOrDestination: Date | string,
    destination?: string
) => {
    // ...
}
```
